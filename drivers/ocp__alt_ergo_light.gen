(*import "cvc4_14.drv"*)

(** Why3 driver for CVC4 1.4 *)

prelude "(*;; produced by cvc4_14.drv ;;*)"
(*prelude "(set-logic AUFBVDTNIRA)"*)
(*prelude "(set-logic ALL)"*)
(*
    A    : Array
    UF   : Uninterpreted Function
    BV   : BitVectors
    DT   : Datatypes
    NIRA : NonLinear Integer Real Arithmetic
*)
(*prelude "(set-info :source |VC generated by SPARK 2014|)"
prelude "(set-info :smt-lib-version 2.6)"
prelude "(set-info :category industrial)"
prelude "(set-info :status unknown)"
*)

(*import "smt-libv2.drv"*)

(* Why3 driver for SMT-LIB2 syntax, excluding bit-vectors *)

prelude "(*;;; generated by SMT-LIB2 driver*)"

(*

Note: we do not insert any command "set-logic" because its
interpretation is specific to provers

prelude "(set-logic AUFNIRA)"

    A  : Array
    UF : Uninterpreted Function
    DT : Datatypes (not needed at the end ...)
    NIRA : NonLinear Integer Reals Arithmetic

*)

invalid "^sat$"
unknown "^\\(unknown\\|Fail\\)$" ""
time "why3cpulimit time : %s s"
valid "^unsat$"

theory BuiltIn
  syntax type int   "int"
  syntax type real  "real"
  syntax predicate (=)  "(%1 = %2)"
  meta "encoding:ignore_polymorphism_ls" predicate (=)
  meta "encoding : kept" type int
end

theory algebra.OrderedUnitaryCommutativeRing
  remove allprops
end

theory algebra.Field
  remove allprops
end

theory algebra.OrderedField
  remove allprops
end

theory int.Int

  prelude "(*;;; SMT-LIB2: integer arithmetic*)"

  syntax function zero "0"
  syntax function one  "1"

  syntax function (+)  "(%1 + %2)"
  syntax function (-)  "(%1 -  %2)"
  syntax function ( * )  "(%1 * %2)"
  syntax function (-_) "(- %1)"

  syntax predicate (<=) "(%1 <= %2)"
  syntax predicate (<)  "(%1 < %2)"
  syntax predicate (>=) "(%1 >= %2)"
  syntax predicate (>)  "(%1 > %2)"

  remove allprops
end

(* 
theory int.Abs
  syntax function abs "(abs %1)"

  remove allprops
  end
*)

(*
theory int.MinMax
  syntax function min "(ite (< %1 %2) %1 %2)"
  syntax function max "(ite (< %1 %2) %2 %1)"

  remove allprops
  end
*)

theory int.EuclideanDivision
  syntax function div "(%1 / %2)"
  syntax function mod "(%1 % %2)"

  remove allprops
end

theory int.Div2
  remove allprops
end

theory int.ComputerDivision
   (* really, you should use bitvectors here, but... *)
end

theory real.Real

  prelude "(*;;; SMT-LIB2: real arithmetic*)"

  meta "encoding : kept" type real

  syntax function zero "0.0"
  syntax function one  "1.0"

  syntax function (+)  "(%1 + %2)"
  syntax function (-)  "(%1 - %2)"
  syntax function ( * )  "(%1 * %2)"
  syntax function (/)  "(%1 / %2)"
  syntax function (-_) "(- %1)"
  syntax function inv  "(1.0 / %1)"

  syntax predicate (<=) "(%1 <= %2)"
  syntax predicate (<)  "(%1 < %2)"
  syntax predicate (>=) "(%1 >= %2)"
  syntax predicate (>)  "(%1 > %2)"

  remove allprops
end

(*
theory real.Abs
  syntax function abs "(ite (>= %1 0.0) %1 (- %1))"

  remove allprops
end
*)

(*
theory real.MinMax
  syntax function min "(ite (< %1 %2) %1 %2)"
  syntax function max "(ite (< %1 %2) %2 %1)"

  remove allprops
end
*)

(*
theory real.FromInt
  syntax function from_int "(to_real %1)"

  remove allprops
end
*)

(*
theory real.Truncate
  syntax function truncate "(ite (>= %1 0.0)
                                 (to_int %1)
                                 (- (to_int (- %1))))"
  syntax function floor "(to_int %1)"
  syntax function ceil "(- 1 (to_int (- 1.0 %1)))"

  remove allprops
end
*)

theory Bool
   meta "encoding : kept" type bool
   meta "eliminate_algebraic" "no_inversion"

   syntax type     bool  "bool"
   syntax function True  "true"
   syntax function False "false"

   remove allprops
end

(* not handled by Alt-Ergo
theory bool.Bool
   syntax function andb  "(%1 and %2)"
   syntax function orb   "(%1 or %2)"
   syntax function xorb  "(%1 xor %2)"
   syntax function notb  "(not %1)"
   syntax function implb "(%1 => %2)"

   remove allprops
end
*)

theory bool.Ite
  syntax function ite "(if %1 then %2 else %3)"
  meta "encoding : lskept" function ite
  meta "encoding:ignore_polymorphism_ls" function ite

  remove allprops
end

theory map.Map
  syntax type map "(%1, %2) farray"
  meta "encoding:ignore_polymorphism_ts" type map

  syntax function get   "(%1[%2])"
  syntax function set   "(%1[%2 <- %3])"
  meta "encoding : lskept" function get
  meta "encoding : lskept" function set
  meta "encoding:ignore_polymorphism_ls" function get
  meta "encoding:ignore_polymorphism_ls" function ([])
  meta "encoding:ignore_polymorphism_ls" function set
  meta "encoding:ignore_polymorphism_ls" function ([<-])

  meta "encoding:ignore_polymorphism_pr" prop Select_eq
  meta "encoding:ignore_polymorphism_pr" prop Select_neq

  remove allprops
end

theory map.Const
  meta "encoding : lskept" function const
(*  syntax function const "(const[%t0] %1)" *)

end



(* import "smt-libv2-bv.gen" no BV in AE *)
(* import "cvc4_bv.gen" no BV in AE *)

import "discrimination.gen"

transformation "inline_trivial"
transformation "eliminate_builtin"
transformation "eliminate_algebraic"
transformation "detect_polymorphism"
transformation "eliminate_inductive"
transformation "eliminate_literal"
transformation "eliminate_epsilon"
transformation "eliminate_if"
transformation "eliminate_let"

transformation "simplify_formula"
(*transformation "simplify_trivial_quantification"*)

transformation "discriminate_if_poly"

(* remove pointless quantifiers from the goal *)
transformation "introduce_premises"

(** Error messages specific to CVC4 *)

outofmemory "(error \".*out of memory\")\\|Cannot allocate memory"
timeout "interrupted by timeout"
steps "smt::SmtEngine::resourceUnitsUsed, \\([0-9]+.?[0-9]*\\)" 1
(**
Unfortunately, there is no specific output message when CVC4 reaches its resource limit
steplimitexceeded "??"
*)

(** Extra theories supported by CVC4 *)

(* Disabled:
   CVC4 seems less efficient with its built-in implementation than
   with the axiomatic version
*)
(*
theory int.EuclideanDivision
   syntax function div "(div %1 %2)"
   syntax function mod "(mod %1 %2)"
   remove prop Mod_bound
   remove prop Div_mod
   remove prop Mod_1
   remove prop Div_1
end
*)


(**** ***** inlined ---> import "smt-libv2-gnatprove.gen" **********************)
(**********************************************************************
 ***                       gnat2why theories                        ***
 **********************************************************************)
(*
theory _gnatprove_standard_th.Integer
   syntax function bool_eq "(%1 = %2)"
   syntax function bool_ne "(not (%1 = %2))"
   syntax function bool_lt "(%1 < %2)"
   syntax function bool_le "(%1 <= %2)"
   syntax function bool_gt "(%1 > %2)"
   syntax function bool_ge "(%1 >= %2)"
   remove allprops
end

theory _gnatprove_standard_th.Boolean_Func
   syntax function bool_eq "(%1 = %2)"
   remove allprops
end

(*************************************************************************)

(** not handled by AE
theory _gnatprove_standard.BVAda
   syntax function bool_eq "(= %1 %2)"
   syntax function bool_ne "(not (= %1 %2))"
   syntax function bool_lt "(bvult %1 %2)"
   syntax function bool_le "(bvule %1 %2)"
   syntax function bool_gt "(bvugt %1 %2)"
   syntax function bool_ge "(bvuge %1 %2)"

   remove allprops
end
**)

(*************************************************************************)

theory ada__model.Discrete_Base
   syntax function bool_eq "(%1 = %2)"
   remove allprops
end

(*************************************************************************)

theory ada__model_th.Discrete_Base_Theory
   syntax function bool_eq "(%1 = %2)"
   remove allprops
end
(**** ***** end ---> import "smt-libv2-gnatprove.gen" **********************)
*)



(*+ FP not handled in an uniform way by all solvers
theory ieee_float.GenericFloat
 remove prop abs_special
 remove prop le_special
 remove prop lt_special
 remove prop eq_special
 remove prop add_special
 remove prop sub_special
 remove prop mul_special
 remove prop div_special
 remove prop neg_special
 remove prop fma_finite
 remove prop fma_special
 remove prop sqrt_finite
 remove prop sqrt_special
end

theory ieee_float.Float32
 remove prop round_bound
end

theory ieee_float.Float64
 remove prop round_bound
end
*)

theory real.Square
 remove allprops
end
